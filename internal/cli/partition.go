package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"

	"github.com/accented-ai/pgtofu/internal/schema"
	"github.com/accented-ai/pgtofu/internal/util"
)

type partitionConfig struct {
	table   string
	schema  string
	modulus int
	output  string
	format  string
}

func newPartitionCommand() *cobra.Command {
	cfg := &partitionConfig{}

	cmd := &cobra.Command{
		Use:   "partition",
		Short: "Generate partition SQL statements",
		Long: `Generate declarative partition SQL statements for hash-partitioned tables.

This command generates CREATE TABLE ... PARTITION OF statements that can be
stored in your schema files for declarative management.

Example usage:
  # Generate 16 partitions for assessment.questions table
  pgtofu partition generate --table questions --schema assessment --modulus 16

  # Generate to a specific file
  pgtofu partition generate --table questions --schema assessment --modulus 16 \
    --output schema/tables/questions_partitions.sql`,
	}

	generateCmd := &cobra.Command{
		Use:   "generate",
		Short: "Generate partition SQL statements",
		Long: `Generate partition creation statements for a hash-partitioned table.

The generated SQL follows PostgreSQL's declarative partition syntax and can be
stored directly in your schema files.`,
		Example: `  # Generate 16 partitions
  pgtofu partition generate --table questions --schema assessment --modulus 16

  # Generate 32 partitions to a file
  pgtofu partition generate --table questions --schema assessment --modulus 32 \
    --output schema/tables/questions_partitions.sql`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runPartitionGenerate(cfg)
		},
	}

	generateCmd.Flags().StringVar(&cfg.table, "table", "",
		"Table name (required)")
	generateCmd.Flags().StringVar(&cfg.schema, "schema", schema.DefaultSchema,
		"Schema name (default: public)")
	generateCmd.Flags().IntVar(&cfg.modulus, "modulus", 16,
		"Number of partitions (MODULUS value)")
	generateCmd.Flags().StringVarP(&cfg.output, "output", "o", "-",
		"Output file path (use '-' for stdout, default: stdout)")
	generateCmd.Flags().StringVar(&cfg.format, "format", "sql",
		"Output format: 'sql' or 'list' (default: sql)")

	generateCmd.MarkFlagRequired("table") //nolint:errcheck

	cmd.AddCommand(generateCmd)

	return cmd
}

func runPartitionGenerate(cfg *partitionConfig) error {
	if cfg.modulus < 1 {
		return fmt.Errorf("modulus must be at least 1, got %d", cfg.modulus)
	}

	if cfg.modulus > 1024 {
		fmt.Fprintf(
			os.Stderr,
			"⚠️  WARNING: %d partitions is very high. PostgreSQL typically performs best with 100-1000 partitions.\n",
			cfg.modulus,
		)
	}

	var output *os.File
	if cfg.output == "-" { //nolint:nestif
		output = os.Stdout
	} else {
		dir := filepath.Dir(cfg.output)
		if dir != "." {
			if err := os.MkdirAll(dir, 0o755); err != nil {
				return util.WrapError("create output directory", err)
			}
		}

		var err error

		output, err = os.Create(cfg.output)
		if err != nil {
			return util.WrapError("create output file", err)
		}
		defer output.Close()
	}

	tableName := fmt.Sprintf("%s.%s", cfg.schema, cfg.table)
	baseName := cfg.table

	switch cfg.format {
	case "list":
		fmt.Fprintf(output, "-- Partitions for %s (MODULUS %d)\n", tableName, cfg.modulus)
		fmt.Fprintf(output, "-- Generated by: pgtofu partition generate\n\n")

		for i := range cfg.modulus {
			fmt.Fprintf(output, "%s_p%d\n", baseName, i)
		}
	case "sql":
		fmt.Fprintf(output, "-- Partitions for %s (MODULUS %d)\n", tableName, cfg.modulus)
		fmt.Fprintf(output, "-- Generated by: pgtofu partition generate\n\n")

		for i := range cfg.modulus {
			partitionName := fmt.Sprintf("%s_p%d", baseName, i)
			fmt.Fprintf(output, "CREATE TABLE %s.%s PARTITION OF %s\n",
				cfg.schema, partitionName, tableName)
			fmt.Fprintf(output, "FOR VALUES WITH (MODULUS %d, REMAINDER %d);\n",
				cfg.modulus, i)

			if i < cfg.modulus-1 {
				fmt.Fprintf(output, "\n")
			}
		}
	default:
		return fmt.Errorf("unknown format: %s (use 'sql' or 'list')", cfg.format)
	}

	if cfg.output != "-" {
		fmt.Fprintf(
			os.Stderr,
			"✓ Generated %d partition statements in: %s\n",
			cfg.modulus,
			cfg.output,
		)
	}

	return nil
}
